\chapter{Трёхмерная графика}
\section{Основные понятия и существующие технологии}
Трёхмерная графика - совокупность приемов и инструментов, предназначенных для отображения объёмных объектов.


Трёхмерное изображение на плоскости отличается от двумерного тем, что включает построение 
геометрической проекции трёхмерной модели сцены на плоскость. Поскольку мы говорим 
о компьютерной графике, под плоскостью подразумевается экран монитора.
Для изображения трехмерных объектов на экране монитора требуется проведение серии процессов 
(обычно называемых конвейером) с последующей трансляцией результата в двумерный вид. 
Первоначально, объект представляется в виде набора точек, или координат, в трехмерном пространстве. 
Трехмерная система координат определяется тремя осями: горизонтальной, вертикальной и осью глубины, 
обычно называемых, соответственно, осями x, y и z. Соединив определённым образом вершины объекта, 
мы получим его каркасную модель. Каркасная модель определяет области, 
которые могут быть заполнены цветом, текстурами и освещаться лучами света.


Очевидно, что для рендеринга трехмерного объекта требуется много вычислений. Если объект движется, 
объём вычислений увеличивается. Поэтому большую часть вычислений, связанных 
с обработкой объекта трёхмерной сцены, берёт на себя графический процессор (Graphics Processing Unit).



\subsection{OpenGL}
OpenGL (Open Graphics Library) ---  спецификация, определяющая независимый от языка программирования 
платформонезависимый программный интерфейс, включающий более 300 функций для рисования сложных 
трёхмерных сцен из простых примитивов. На основе этой спецификации производители графических процессоров
создают реализации --- библиотеки функций, соответствующие набору функций спецификации.

OpenGL не включает функций для создания окон или для захвата пользовательского ввода. Поэтому существует 
ряд библиотек, обеспечивающих такие возможности, как создание интерфейса пользователя, настройка контекста 
рисования и обработка сообщений от устройств ввода-вывода.  Примерами таких библиотек могут служить GLUT, SDL, GLFW и т.д.


\section{Процесс визуализации объектов}
\subsection{Представление объекта в памяти компьютера}
Рассмотрим подробнее процесс рендеринга объектов. В настоящее время в компьютерной графике популярно представление
поверхностей в виде полигональной сетки (совокупности вершин, рёбер и граней, которые определяют форму многогранного объекта). 
Гранями в компьютерных играх, как правило, являются треугольники, поскольку графические процессоры 
способны на аппаратном уровне быстро обрабатывать этот примитив. У каждой вершины треугольника есть так называемые 
атрибуты, среди которых, естественно, координаты вершины в пространстве, вектор нормали, координаты текстуры и т.д. 
Таким образом описание объекта сводится к описанию атрибутов вершин треугольников, из которых состоит его поверхность. 
Атрибуты вершин принято хранить в массиве (в одном или нескольких для каждого из атрибутов). Далее, 
используя функции OpenGL, следует сообщить графическому процессору о созданном объекте и вызвать функцию отрисовки, 
которая в соответствии с определёнными правилами отрисует вершины в таком порядке, 
в каком они расположены в описанном массиве. Часто возникает ситуация, когда вершина принадлежит нескольким треугольникам, 
а значит при вышеописанном подходе её необходимо дублировать столько раз, сколько треугольников её содержит. 
В объектах с большим количеством треугольников это может привести к бессмысленной трате памяти, поэтому 
часто используется так называемый буфер индексов - массив, каждый элемент которого есть индекс определённой вершины
в массиве вершин. Можно вызвать функцию отрисовки таким образом, чтобы графический процессор отрисовывал вершины в 
том порядке, в котором расположены их индексы в буфере индексов.
\subsection{Процесс обработки вершин. Шейдеры}
При вызове функции отрисовки каждая точка, принадлежащая текущему объекту, проходит несколько этапов обработки, 
и только после этого проецируется на экран. Эти этапы, как было отмечено ранее, в совокупности составляют 
графический конвейер, который представлен следующим образом:
\begin{enumerate}
\item Вершинный процессор
\item Геометрический процессор
\item Клиппер (обрезает те фрагменты, которые не попадают на экран
\item Фрагментный процессор
\end{enumerate}


Далее следует ввести понятие шейдера

\textbf{Шейдер} --- программа для одной из ступеней графического конвейера, используемая в трёхмерной графике 
для определения окончательных параметров объекта или изображения.
Существует три вида шейдеров: вершинный (оперирует данными, сопоставленными с вершинами треугольников), 
фрагментный (работает с фрагментами растрового изображения) и геометрический (способен за одно выполнение 
обработать целый треугольник). Есть несколько языков программирования, разработанных для создания шейдеров. 
Наиболее популярным является GLSL (The OpenGL Shading Language). Код, написанный на GLSL, обрабатывается компилятором, 
который является частью драйвера видеокарты, затем используется видеопроцессором. Спецификация OpenGL предоставляет 
функции для загрузки и компиляции шейдеров, а также для обмена данными между шейдером и основным приложением.

Итак, каждый шейдер выполняется на соответствующем этапе графического конвейера, затем осуществляется рендеринг изображения.

\section{Преобразования координат вершин}
Данный раздел представляет наибольший интерес, поскольку преобразования координат тесно связаны с линейной алгеброй. 
Следует отметить, что несмотря на возможность представления поворота и масштабирования матрицами размера \begin{math}3\times3\end{math}, 
перемещение представить матрицей такого размера невозможно, поэтому принято использовать матрицы размера \begin{math}4\times4\end{math}. 
Далее все преобразования рассматриваются в случае трёхмерного пространства.
\subsection{Масштабирование}
Масштабирование - наиболее простое преобразование, которое может быть представлено матрицей вида
\begin{equation}
\mathrm{S} = 
  \begin{pmatrix}
    \lambda & 0 & 0 & 0 \\
    0 & \lambda & 0 & 0 \\
    0 & 0 & \lambda & 0 \\
    0 & 0 & 0 & 1
  \end{pmatrix},
\end{equation}
\begin{eqrem}
\begin{math} \lambda \end{math} --- коэффициент масштабирования.
\end{eqrem}

\subsection{Вращение}
Вращение есть произведение матриц поворота вокруг некоторых ортогональных осей на 
определённый угол (в данном случае - вокруг координатных осей):

\begin{equation}
\mathrm{R}_x = 
  \begin{pmatrix}
    1 & 0  & 0 & 0\\
    0 & \cos\varphi & -\sin\varphi & 0\\
    0 & \sin\varphi & \cos\varphi & 0\\
    0 & 0 & 0 & 1
  \end{pmatrix},
\end{equation}

\begin{equation}
\mathrm{R}_y = 
  \begin{pmatrix}
    \cos\psi  & 0 & -\sin\psi & 0\\
    0 & 1 & 0 & 0 \\
    \sin\psi & 0 & \cos\psi & 0\\
    0 & 0 & 0 & 1
  \end{pmatrix},
\end{equation}

\begin{equation}
\mathrm{R}_z = 
  \begin{pmatrix}
    \cos\eta & -\sin\eta & 0 & 0 \\
    \sin\eta & \cos\eta  & 0 & 0\\
    0 & 0 & 1 & 0\\
    0 & 0 & 0 & 1
  \end{pmatrix},
\end{equation}
\begin{eqrem}
\begin{math} \varphi, \psi, \eta\end{math} --- соответственно углы поворота вокруг осей \begin{math}x, y, z\end{math}.
\end{eqrem}

Результирующее преобразование: \begin{math}\mathrm{R} = \mathrm{R}_z \mathrm{R}_y \mathrm{R}_x\end{math}.

\subsection{Перемещение}
Матрица перемещения достаточно простого вида:

\begin{equation}
\mathrm{T} = 
  \begin{pmatrix}
    1 & 0  & 0 & x\\
    0 & 1 & 0 & y\\
    0 & 0 & 1 & z\\
      0 & 0 & 0 & 1
  \end{pmatrix},
\end{equation}
\begin{eqrem}
\begin{math} x, y, z \end{math} - координаты вектора перемещения.
\end{eqrem}

\subsection{Результирующее преобразование}
Для получения результирующего преобразования следует переменожить все вышеперечисленные матрицы 
в строго определённом порядке. Нужно иметь ввиду, что вектор позиции вершины умножается на матрицу справа, 
а значит преобразуется каждой матрицей справа налево. В трёхмерной графике принято сначала изменять масштаб объекта, 
затем вращать и после перемещать; после этого могут применяться дополнительные преобразования, связанные с камерой 
и проекцией перспективы, о которых пойдёт речь далее. Затем посредством функций из OpenGL нужно отправить получившуюся 
матрицу в вершинный шейдер, в котором матрица будет умножаться на координаты каждой вершины для достижения итоговой 
позиции в пространстве.